## 연관 관계 매핑
- **연관관계 매핑**: 연관 관계에 있는 상대 테이블의 PK를 멤버변수로 갖지 않고, 엔티티 객체 자체를 통째로 참조
- **방향성**: 데이터 모델링에선 관계를 맺으면 자동으로 양방향으로 설정되지만, 객체지향 모델링에선 서비스에따라 단방향인지 양방향인지 선택 필요.
- **연관관계 주인**: 양방향에서 한쪽을 연관관계 주인으로 두며, 주인만이 외래키를 관리할 수 있음(등록, 수정, 삭제)
- **FetchType**: 항상 한번에 연관된 데이터를 다 가지고오면 효율이 떨어지기 때문에 데이터를 조회하는 시점을 정할 수 있다.

### JPA 연관관계 매핑
- Mybatis와 다르게 JPA는 연관 관계에 있는 상대 테이블의 엔티티 객체 자체를 통째로 참조한다.
- 테이블 지향 모델링이 아닌 객체지향 모델링
- 관계 종류로는 *OneToOne*, *OneToMany*, *ManyToOne*, *ManyToMany* 가 있다.

#### OneToOne
- 단방향
- 외래키 컬럼에 선언

#### ManyToOne
- 단방향

#### OneToMany
- 단방향
- 외래키 설정이 없으면 컬럼 매핑을 못해 조인테이블을 생성
- `@JoinColumn`을 이용해 외래키 매핑이 필요

#### 방향성 (양방향 vs 단방향)
- 데이터 모델링에서는 관계를 맺어주면 자동으로 양방향 관계로 설정
- 객체지향 모델링에서는 구현하고자 하는 서비스에 따라 단방향 관계인지, 양방향 관계인지 적절한 선택 필요
- 사실 객체지향 모델링에서 양방향 관계란 서로 다른 단방향 연관관계 2개를 애플리케이션 로직으로 잘 묶어서 양방향인 것처럼 보이게 할 뿐, 양방향 연관 관계는 존재하지 않음

#### 연관관계 주인
- 주인이 아닌 쪽에 `mappedBy`라는 옵션을 사용
- **외래키가 있는 쪽이 주인**
- DB상에서 컬럼값으로 연관된 FK를 주인으로 가진 쪽을 주인으로 두는게 좋음

#### FetchType.EAGER
- 즉시 로딩으로 엔티티를 조회할 때 연관된 엔티티도 함께 조회
- OneToOne, ManyToOne 의 기본값

#### FetchType.LAZY
- 지연 로딩으로 연관된 엔티티를 실제 사용할 때 조회.
- OneToMany, ManyToMany 의 기본값
- **하이버네이트에선 모두 이게 기본값.**
- 지연 로딩은 `user.findById()`일 때는 프록시이고, `user.getId()`와 같은 것은 실제 객체를 가지고 온다.
  - 지연 로딩할 때는 id값만 있고, 다른 값들은 프록시 값이 들어있다.

#### OneToOne + OneToOne
- 외래키가 생기지 않길 바라는 쪽에 `mappedBy`를 선언

#### OneToMany + ManyToOne
- *OneToMany* 쪽에 외래키 매핑이 필요함
- 양방향이면 주인이 아닌 쪽에 OneToMany의 엘리먼트로 `mappedBy`를 사용


## 참고 자료
- <https://stackoverflow.com/questions/26601032/default-fetch-type-for-one-to-one-many-to-one-and-one-to-many-in-hibernate>
